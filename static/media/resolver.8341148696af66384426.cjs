function _catch(e,r){try{var t=e()}catch(o){return r(o)}return t&&t.then?t.then(void 0,r):t}function inMemoryCache(){const e=new Map;return function(r,t){try{let s;function o(o){if(s)return o;const n=e.get(r.didUrl);return void 0!==n?n:Promise.resolve(t()).then((function(t){var o;return"notFound"!==(null==(o=t.didResolutionMetadata)?void 0:o.error)&&e.set(r.didUrl,t),t}))}const i=function(){if(r.params&&"true"===r.params["no-cache"])return Promise.resolve(t()).then((function(e){return s=1,e}))}();return Promise.resolve(i&&i.then?i.then(o):o(i))}catch(n){return Promise.reject(n)}}}function noCache(e,r){return r()}const PCT_ENCODED="(?:%[0-9a-fA-F]{2})",ID_CHAR=`(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`,METHOD="([a-z0-9]+)",METHOD_ID=`((?:${ID_CHAR}*:)*(${ID_CHAR}+))`,PARAM_CHAR="[a-zA-Z0-9_.:%-]",PARAM=`;${PARAM_CHAR}+=${PARAM_CHAR}*`,PARAMS=`((${PARAM})*)`,PATH="(/[^#?]*)?",QUERY="([?][^#]*)?",FRAGMENT="(#.*)?",DID_MATCHER=new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}(#.*)?$`);function parse(e){if(""===e||!e)return null;const r=e.match(DID_MATCHER);if(r){const t={did:`did:${r[1]}:${r[2]}`,method:r[1],id:r[2],didUrl:e};if(r[4]){const e=r[4].slice(1).split(";");t.params={};for(const r of e){const e=r.split("=");t.params[e[0]]=e[1]}}return r[6]&&(t.path=r[6]),r[7]&&(t.query=r[7].slice(1)),r[8]&&(t.fragment=r[8].slice(1)),t}return null}const EMPTY_RESULT={didResolutionMetadata:{},didDocument:null,didDocumentMetadata:{}};function wrapLegacyResolver(e){return function(r,t,o){try{return Promise.resolve(_catch((function(){return Promise.resolve(e(r,t,o)).then((function(e){return{...EMPTY_RESULT,didResolutionMetadata:{contentType:"application/did+ld+json"},didDocument:e}}))}),(function(e){return{...EMPTY_RESULT,didResolutionMetadata:{error:"notFound",message:e.toString()}}})))}catch(n){return Promise.reject(n)}}}class Resolver{constructor(e={},r={}){this.registry=void 0,this.cache=void 0,this.registry=e,this.cache=!0===r.cache?inMemoryCache():r.cache||noCache,r.legacyResolvers&&Object.keys(r.legacyResolvers).map((e=>{this.registry[e]||(this.registry[e]=wrapLegacyResolver(r.legacyResolvers[e]))}))}resolve(e,r={}){try{const t=this,o=parse(e);if(null===o)return Promise.resolve({...EMPTY_RESULT,didResolutionMetadata:{error:"invalidDid"}});const n=t.registry[o.method];return n?Promise.resolve(t.cache(o,(()=>n(o.did,o,t,r)))):Promise.resolve({...EMPTY_RESULT,didResolutionMetadata:{error:"unsupportedDidMethod"}})}catch(t){return Promise.reject(t)}}}exports.Resolver=Resolver,exports.inMemoryCache=inMemoryCache,exports.noCache=noCache,exports.parse=parse,exports.wrapLegacyResolver=wrapLegacyResolver;